// Copyright 2018 Prodrive Technologies, https://prodrive-technologies.com/
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"archive/zip"
	"encoding/xml"
	"errors"
	"flag"
	"io/ioutil"
	"net/http"
	"os"
	"os/exec"
	"os/signal"
	"path/filepath"
	"sync"
	"syscall"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/common/log"
)

var (
	hpraidScrapeSuccessDesc = prometheus.NewDesc(
		prometheus.BuildFQName("hpraid", "", "scrape_success"),
		"Whether scraping the HP RAID controller stats was successful.",
		nil, nil)
	hpraidErrorsDesc = prometheus.NewDesc(
		prometheus.BuildFQName("hpraid", "", "errors"),
		"Errors in the diagnostic report reported by the RAID controller.",
		[]string{"device", "message", "severity"}, nil)

	temporaryZipPath = ""
)

// ADUReport is the top level structure contained in the XML report file
// generated by ssacli.
type ADUReport struct {
	XMLName xml.Name `xml:"ADUReport"`
	Devices []Device `xml:"Device"`
}

// Collect data from the XML report and convert it to Prometheus metrics.
func (r *ADUReport) Collect(ch chan<- prometheus.Metric) {
	for _, device := range r.Devices {
		device.Collect("", ch)
	}
}

// Device contains per-device information in the XML report file
// generated by ssacli.
type Device struct {
	DeviceType    string    `xml:"deviceType,attr"`
	MarketingName string    `xml:"marketingName,attr"`
	Errors        []Message `xml:"Errors>Message"`
	Devices       []Device  `xml:"Device"`
}

// Collect data from the per-device object and convert it to Prometheus metrics.
func (d *Device) Collect(devicePrefix string, ch chan<- prometheus.Metric) {
	if len(devicePrefix) > 0 {
		devicePrefix += "/"
	}
	devicePrefix += d.DeviceType
	devicePrefix += "="
	devicePrefix += d.MarketingName

	for _, message := range d.Errors {
		message.Collect(devicePrefix, ch)
	}
	for _, device := range d.Devices {
		device.Collect(devicePrefix, ch)
	}
}

// Message contains an error message part of the XML report file
// generated by ssacli.
type Message struct {
	Message  string `xml:"message,attr"`
	Severity string `xml:"severity,attr"`
}

// Collect data from an error message and convert it to a Prometheus metric.
func (m *Message) Collect(devicePrefix string, ch chan<- prometheus.Metric) {
	ch <- prometheus.MustNewConstMetric(
		hpraidErrorsDesc, prometheus.GaugeValue, 1.0,
		devicePrefix, m.Message, m.Severity)
}

// HpraidExporter is a Prometheus exporter implementation that calls
// into the "ssacli" utility to generate a diagnostic report for HP
// RAID hardware. It then converts the diagnostic report into Prometheus
// metrics.
type HpraidExporter struct {
	collectLock      sync.Mutex
	utilityPath      string
	temporaryZipPath string
}

// Describe metrics provided by the HP RAID exporter.
func (e *HpraidExporter) Describe(ch chan<- *prometheus.Desc) {
	ch <- hpraidScrapeSuccessDesc
	ch <- hpraidErrorsDesc
}

func collectFromUtility(utilityPath string, temporaryZipPath string, ch chan<- prometheus.Metric) error {
	// Invoke diagnostic utility in such a way that it writes into a zip file.
	cmd := exec.Command(utilityPath, "ctrl", "all", "diag", "file="+temporaryZipPath)
	if err := cmd.Run(); err != nil {
		return err
	}

	// Look for the XML file stored in the zip file.
	z, err := zip.OpenReader(temporaryZipPath)
	if err != nil {
		return err
	}
	var xmlFile *zip.File
	defer z.Close()
	for _, f := range z.File {
		if f.Name == "ADUReport.xml" {
			xmlFile = f
		}
	}
	if xmlFile == nil {
		return errors.New("Zip file does not contain ADUReport.xml")
	}

	// Parse the XML data.
	reader, err := xmlFile.Open()
	if err != nil {
		return err
	}
	defer reader.Close()
	xmlDecoder := xml.NewDecoder(reader)
	var report ADUReport
	err = xmlDecoder.Decode(&report)
	if err != nil {
		return err
	}

	// Extract Prometheus metrics from the report.
	report.Collect(ch)
	return nil
}

// Collect metrics from HP RAID hardware.
func (e *HpraidExporter) Collect(ch chan<- prometheus.Metric) {
	e.collectLock.Lock()
	err := collectFromUtility(e.utilityPath, e.temporaryZipPath, ch)
	e.collectLock.Unlock()
	if err == nil {
		ch <- prometheus.MustNewConstMetric(
			hpraidScrapeSuccessDesc, prometheus.GaugeValue, 1.0)
	} else {
		log.Error("Failed to gather stats: ", err)
		ch <- prometheus.MustNewConstMetric(
			hpraidScrapeSuccessDesc, prometheus.GaugeValue, 0.0)
	}
}

func newHpraidExporter(utilityPath string, temporaryZipPath string) (*HpraidExporter, error) {
	return &HpraidExporter{
		utilityPath:      utilityPath,
		temporaryZipPath: temporaryZipPath,
	}, nil
}

func initTemporaryZipPath() {
	var err error
	temporaryZipPath, err = ioutil.TempDir("", "hpraid")
	if err != nil {
		log.Fatalf("failed to create temporary zip path: %s", err)
	}
	log.Debug("Using %s as temporary zip directory", temporaryZipPath)
}

func setupExitHandler() {
	// Properly clean up before exit'ing on kill or Ctrl+C
	sigs := make(chan os.Signal, 1)
	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)
	go func() {
		<-sigs
		log.Info("Cleaning up")
		cleanTemporaryZipPath()
		os.Exit(0)
	}()
}

func cleanTemporaryZipPath() {
	os.RemoveAll(temporaryZipPath)
}

func main() {
	var (
		listenAddress = flag.String("web.listen-address", ":9423", "Address to listen on for web interface and telemetry.")
		metricsPath   = flag.String("web.telemetry-path", "/metrics", "Path under which to expose metrics.")
		utilityPath   = flag.String("hpraid.utility-path", "ssacli", "Path of the ssacli utility.")
	)
	flag.Parse()

	log.Info("Starting hpraid_exporter")

	initTemporaryZipPath()
	defer cleanTemporaryZipPath()
	setupExitHandler()
	exporter, err := newHpraidExporter(*utilityPath, filepath.Join(temporaryZipPath, "hpraid_exporter.zip"))
	if err != nil {
		panic(err)
	}
	prometheus.MustRegister(exporter)

	http.Handle(*metricsPath, prometheus.Handler())
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte(`
			<html>
			<head><title>Hpraid Exporter</title></head>
			<body>
			<h1>Hpraid Exporter</h1>
			<p><a href='` + *metricsPath + `'>Metrics</a></p>
			</body>
			</html>`))
	})
	log.Info("Listening on address:port => ", *listenAddress)
	log.Fatal(http.ListenAndServe(*listenAddress, nil))
}
